.TH "el_option" "3" "26 January 2018 (v0.2.0)" "bofc.pl"
.SH NAME
.B el_option
- sets optional configuration of the logger
.SH SYNOPSIS
.PP
.B #include <embedlog.h>
.PP
.BI "int el_option(enum el_option " option ", " ... ")"
.br
.BI "int el_ooption(struct el_options *" options ", \
enum el_option " option ", " ... ")"
.SH DESCRIPTION
.PP
.BR el_option (3)
allows user to configure logger's internal options, to tune logging to users
needs.
.SH OPTIONS
.PP
Below is a list of
.I option
that can be configured.
Value inside parenthesis determines argument types of variadic arguments
.I ...
.PP
.BI "EL_LEVEL (" enum " " el_level " level)"
.RS
.   B EL_LEVEL
sets what the current logging level shall be.
Altough it accepts
.   B enum el_level
type, this can be whatever number from range <0, INT_MAX>.
The higher the level, the lower priority of the message.
All messages that have lower priority (higher number) then currently set
.   I level
will not be printed.
There are 8 predefined levels, sorted by priority (highest first):
.   PP
.   RS
.       B EL_FATAL,
.       br
.       B EL_ALERT,
.       br
.       B EL_CRIT,
.       br
.       B EL_ERROR,
.       br
.       B EL_WARN,
.       br
.       B EL_NOTICE,
.       br
.       B EL_INFO,
.       br
.       B EL_DBG
.   RE
.   PP
If 8 print levels are not enough, one can define new levels, knowing that
.   B EL_FATAL
has int value of 0, and
.   B EL_DBG
has int value of 7.
User can also use debug level and add an integer like:
.   B EL_DBG
+
.   I n
- where
.   I n
can be any number from range <0, INT_MAX - 8>.
.   PP
If messages are printed with lower priority than
.   B EL_DBG
they all will be treated as messages printed with level
.   BR EL_DBG ,
that means message printed with level
.   B EL_DBG
and
.   BR "EL_DBG + 3" ,
will be printed exactly the same, so same color (if colors are enabled) and if
log level printig is enabled, such messages will have same 'd/' prefix no matter
the level.
.   PP
.   B ERRORS
.   RS
Setting log level cannot fail
.   RE
.RE
.PP
.BI "EL_OUT (" enum " " el_output " outputs)"
.RS
.   B EL_OUT
simply sets to what
.IR outputs .
logs will be printed to with any of the printing
function.
User can enable as many outputs as he desires - it can be all inputs or even
none (if one wants to surpress logging for some time).
To enable multiple outputs join values with
.   B or
operator (
.   B |
).
.   PP
Currently following
.I outputs
can be enabled.
.   PP
.   B EL_OUT_STDERR
.   RS
Messages will be printed to standard error output
.   RE
.   PP
.   B EL_OUT_SYSLOG
.   RS
Messages will be sent to syslog facility. This requires system with implemented
POSIX.1-2001 and any syslog daemon
.   RE
.   PP
.   B EL_OUT_FILE
.   RS
Messages will be printed to file.
To work user should set output file with
.       BR EL_FNAME .
Log rotation can be configured with
.       B EL_FROTATE_NUMBER
and
.       R EL_FROTATE_SIZE
options.
.   RE
.   PP
.   B EL_OUT_NET
.   RS
Messages shall be printed to external server.
This requires BSD Sockets to be enabled on the clients system, and listening
server.
(TODO Not implemented yet)
.   RE
.   PP
.   B EL_OUT_TTY
.   RS
Prints messages directly to configured serial console
.   RE
.   PP
.   B EL_OUT_ALL
.   RS
Enables all supported outputs at once
.   RE
.   PP
.   B EL_OUT_NONE
.   RS
Disables every output - logs won't be printed at all
.   RE
.   PP
.   B EL_OUT_CUSTOM
.   RS
Enables custom function to be called on log print.
Pointer to custom function needs to be set with
.       B EL_CUSTOM_PUTS
option.
.   RE
.   PP
Many of the outputs can be configured for special needs, and some of them need
mandatory configuration.
For information about output configuration see proper option description
.   PP
.   B ERRORS
.   RS
.       B EINVAL
.       RS
Specified
.           I output
is invalid
.       RE
.   RE
.   PP
.   RS
.       B ENODEV
.       RS
Specified
.I          output
is not implemented on current system (support was not compiled into library)
.       RE
.   RE
.RE
.PP
.BI "EL_COLORS (" int " colors)"
.RS
If this is set to 1, output will be enriched with ANSI colors depending on the
message severity.
This option needs terminal supporting colors.
You can store messages with colors to file, and then read them with colors on
color-enabled terminal.
If this is set to 0, no colors will be added.
.   PP
.   B ERRORS
.   RS
.       B EINVAL
.       RS
Input argument is different than 1 or 0
.       RE
.   RE
.RE
.PP
.BI "EL_TS (" enum " " el_option_timestamp " timestamp)"
.RS
Allows timestamp to be added to each log message. Possible values for
.I timestamp
are:
.   PP
.   B EL_TS_OFF
.   RS
Timestamp will not be added to messages
.   RE
.   PP
.   B EL_TS_SHORT
.   RS
Short timestamp will be added to log in format
.       B [1503661223.537631]
.   RE
.   PP
.   B EL_TS_LONG
.   RS
Long timestamp will be added to log in format
.       B [2017-08-25 11:40:23.537651]
.   RE
.   PP
.   B ERRORS
.   RS
.       B EINVAL
.       RS
Input argument is invalid
.       RE
.       PP
.       B ENOSYS
.       RS
Timestamp support was not compiled in and setting this options is disabled
.       RE
.   RE
.RE
.PP
.BI "EL_TS_TM (" enum " " el_option_timestamp_timer " timer)"
.RS
Sets the timer source for the timestamp print.
.   PP
.   B EL_TS_TM_CLOCK
.   RS
Library will use value from
.       BR clock ()
function.
With this clock precission varies from 10^-3[s] to 10^-9[s].
On POSIX systems, this clock has precision of 10^-6[s].
This timer has a lot drawbacks, time value is unspecified at the beggining of
the program, timer is not incremented when thread is sleeping, timer will
overlap eventually (on 32bit systems with POSIX it takes around 72 minutes for
the clock to overlap).
On the other hand this is the most precise clock for pure c89 systems without
POSIX.
.   RE
.   PP
.   B EL_TS_TM_TIME
.   RS
Time is taken from
.       BR time ()
function.
This returns current wall clock of the system, it's precision is very low
(1[s]), but it's pure c89 and it is good for logging low frequent messages.
This clock is susceptible to unexpected time change (from NTP or by root
itself).
.   RE
.   PP
.   B EL_TS_TM_REALTIME
.   RS
Time is taken from
.       BR clock_gettime ()
using
.       B CLOCK_REALTIME
clock.
This required system with POSIX.1-2001.
This time returns current system wall clock, but it's precision is much higher
than
.       B EL_TS_TM_TIME
clock (depending on system it can vary from 10^-3[s] up to even 10^-9[s]).
Just like it is with
.       B EL_TS_TM_TIME
this timestamp can jump forward of backward if it is changed in the system.
.   RE
.   PP
.   B EL_TS_TM_MONOTONIC
.   RS
This clock is similar to
.       B EL_TS_TM_REALTIME
but it shows time from unspecified time and is not affected by time change
(it can still be altered with
.       BR adjtime ()
or NTP)
.   RE
.   PP
.   B ERRORS
.   RS
.       B EINVAL
.       RS
Input argument is invalid
.       RE
.       PP
.       B ENODEV
.       RS
Specified timer source was not compiled in and is not available
.       RE
.   RE
.RE
.PP
.BI "EL_PRINT_LEVEL (" int " print)"
.RS
If this is set to 1, each log will have log level information prefix in format
"l/" where 'l' is first character of level message is printed with, for example:
.   PP
.   RS
c/this is critical message
.       br
n/this is just a notice
.       br
d/debug print
.   RE
.PP
If value is set to 0, level information will not be added, and above messages
would like like this
.PP
.   RS
this is critical message
.       br
this is just an notice
.       br
debug print
.   RE
.   PP
.   B ERRORS
.   RS
.       B EINVAL
.       RS
Input argument is different than 1 or 0
.       RE
.   RE
.RE
.PP
.BI "EL_FINFO (" int " finfo)"
.RS
If set to 1, adds information about log location to each message in format
[some_file.c:123]. Setting this to 0, will result in no file information at all
.   PP
.   B ERRORS
.   RS
.       B EINVAL
.       RS
Input argument is different than 1 or 0
.       RE
.   RE
.RE
.PP
.B EL_CUSTOM_PUTS (
.I int (*el_custom_puts)(const char *s)
.B )
.RS
Sets function pointer for custom message print.
Function will receive complete messsage to print, just as it would be printed to
ie. stderr or another facility.
Function cannot fail, if NULL is passed, custom function won't be called.
It is still mandatory to enable custom printing with
.   BR el_option (3)
.RE
.PP
.BI "EL_FNAME (" const " " char " " * "path)"
.RS
Sets the
.I path
for the logs. Logs will be stored in this file. If file
rotation is enabled, a numer will be postfixed to each file. See
.   B EL_FROTATE_NUMBER
in this page for more details.
.   PP
.   B ERRORS
.   RS
.       B EINVAL
.       RS
Input parameter is NULL
.       RE
.       PP
.       B ENAMETOOLONG
.       RS
File name is too long
.       RE
.       PP
Function can also fail and set
.       I errno
for any of the errors specified for the routing
.       BR fopen ()
.   RE
.PP
If function fails, file is not opened and any calls that logs to file will
result in failure.
.RE
.PP
.BI "EL_FROTATE_NUMBER (" long " number)"
.RS
If set to 0, file rotation will be disabled and logs will be printed into
specified file without size limit.
The only size limit is the one presented by the filesystem and architecture.
.   PP
If this value is bigger than 0, file rotation will be enabled. All files will
have suffixes added to name set in EL_FNAME. For example,
.   IR program.log.0 .
Files are enumareted from
.   I .0
to
.   IR .n ,
where
.   I n
is set rotate number.
File with suffix
.   I .0
is the oldest one, and the higher the number, the newer the file is.
If logger reaches maximum number of files, oldest one with suffix
.   I .0
will be deleted and suffixes of the files will be decremented by 1 (ie.
.   I log.1
will be renamed to
.   IR log.0 ,
.   I log.2
will be renamed to
.   I log.1
and so on.
.   PP
User can also pass 1 here, but if file reaches its size limit, it will be
deleted and printing will continue from the empty file
.   PP
.   B ERRORS
.   RS
.       B EINVAL
.       RS
Input parameter is less than 0
.       RE
.   RE
.RE
.PP
.BI "EL_FROTATE_SIZE (" long " size)"
.RS
This defines
.I size
at which files will be rotated.
If message being printed would overflow rotate size, current file will be closed
and new one will be created, and current message will be stored in that new
file.
It is guaranteed that file will not be bigger than value set in this option.
If log printed into file is bigger than configure rotate size, message will be
truncated, to prevent file bigger than configure rotate size.
It's very rare situation as it doesn't make a lot of sense to set rotate size to
such small value.
.   PP
.   B ERRORS
.   RS
.       B EINVAL
.       RS
Value is less than 1
.       RE
.   RE
.RE
.SH RETURN VALUE
.PP
On success 0 is returned. -1 is returned when any error occured.
.SH ERRORS
.TP
.B EINVAL
Passed
.I option
is invalid.
.TP
.B ENOSYS
Passed
.I option
is not supported on this system (support was not compiled)/
Also check for error description of specific option that failed for more
informations
.SH SEE ALSO
.PP
.BR el_init (3),
.BR el_cleanup (3),
.BR el_overview (7),
.BR el_puts (3),
.BR el_print (3),
.BR el_vprint (3),
.BR el_perror (3),
.BR el_pmemory (3),
.BR el_ocleanup (3),
.BR el_oputs (3),
.BR el_oprint (3),
.BR el_ovprint (3),
.BR el_operror (3),
.BR el_opmemory (3),
